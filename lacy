#!/usr/bin/env bash

# lacy - Compile and run C
# 
# Takes your C code, compiles it with gcc, then runs.
# The source is a complete C file or only statements.
# In that case, lacy adds classic headers and puts your statements into main().
# 
# USAGE
# 
# File :
# $ lacy hello.c
# Hello!
# 
# File + args :
# $ lacy hello.c Bob
# Hello Bob!
# 
# Pipe :
# $ cat hello.c | lacy
# Hello!
# 
# Prompt :
# $ lacy
# int i = 10;
# printf("%d\n", i);
# [CTRL+D]
# 10
# 
# Inline :
# $ lacy 'printf("%s\n", "Hello!");'
# Hello!
# 
# Print template :
# $ lacy > new.c
# (avoids typing boilerplate)
# 
# $ lacy -h (help)
# $ lacy -v (version)
# 
# AUTHOR : Francois Alcover

#=============================================================

# strict mode
set -e
set -u
set -o pipefail

app=lacy
runc_version='0.2'

runc_headers="\
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <math.h>
#include <inttypes.h>
#include <complex.h>
#include <float.h>
#include <string.h>
#include <limits.h>
#include <ctype.h>
#include <locale.h>
#include <time.h>
#include <assert.h>
#include <errno.h>
"

runc_tpl="\
// file generated by $app

$runc_headers
int main (int argc, char **argv)
{
	@code
	return 0;
}
"

# -lc ?
runc_flags="-std=gnu11 -lm -Wno-pedantic -Wno-unused-variable"

bold=$(tput bold)
norm=$(tput sgr0)

runc_help="\
$app - compile and run C

Takes your C code, compiles it with gcc, then runs.
The source is a complete C file or only statements.
In that case, $app adds classic headers and puts your statements into main().

Usage:    

- COMPLETE FILE :
//hello.c
#include <stdio.h>
void main() {
    printf (\"%s\n\", "Hello!");
}

${bold}$ $app hello.c
Hello!
${norm}

- STATEMENTS FILE :
//stmts.c
int i = 10;
printf ("%d\n", i);

${bold}$ cat stmts.c | $app
10
${norm}

- PROMPT (enter statements then CTRL+D) :
${bold}$ $app${norm}
int i = 10;
printf (\"%d\n\", i);
[CTRL+D]
${bold}$ 10${norm}

- INLINE :
${bold}$ $app 'printf(\"Hello!\");'${norm}

- PRINT TEMPLATE :
${bold}$ $app > new.c${norm}

- get version :
${bold}$ $app -v${norm}
"

#=============================================================

srcpath=''
code=''
args=''

# no arguments
if [ $# -eq 0 ]; then

	# term in
	if [[ -t 0 ]]; then
		# term out
		if [[ -t 1 ]]; then
			echo "(Help : $app -h)"
			echo "Enter lines of code then hit CTRL+D :"
		else
			# print template
			echo -n "${runc_tpl/@code/}"
	    	exit 0
	    fi
	fi

	code=$(</dev/stdin)

else

	# help
	if 	[ "$1" = '-h' ] || [ "$1" = '--help' ]; then
		echo "$runc_help"
		exit 0
	fi

	# version
	if 	[ "$1" = '-v' ]; then
		echo "$runc_version"
		exit 0
	fi

	# source is a file
	if [ -f "$1" ]; then
		# self-standing
		if grep -P -q '(int|void)\s+main' "$1"; then
			srcpath=$1
		else
			code=$(<"$1")
		fi
	else
		code="$1"
	fi

	shift
	args=$*
fi

tmp=$(mktemp -q)

if [ -z "$srcpath" ]; then

	srcpath="$tmp.c"
	
	# if no main(), wrap in template
	hasmain=false
	echo "$code" | grep -P -q '(int|void)\s+main' && hasmain=true
	if ! $hasmain; then
		code=${runc_tpl/@code/$code}
	fi
	
	echo -n "$code" > "$srcpath"
	echo "(saved as $srcpath)"
fi

exepath="$tmp"

gcc $runc_flags "$srcpath" -o "$exepath" \
&& "$exepath" "$args" \
&& rm -f "$exepath" \
&& exit 0